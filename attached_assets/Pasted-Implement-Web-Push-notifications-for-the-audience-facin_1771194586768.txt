Implement Web Push notifications for the audience-facing app. This has 4 parts:

PART A - SERVER SETUP: (1) Install the web-push npm package. (2) Generate VAPID keys using web-push.generateVAPIDKeys() and store them as environment variables VAPID_PUBLIC_KEY and VAPID_PRIVATE_KEY with VAPID_EMAIL set to admin contact email. Run key generation once and save the output. (3) Add a device_push_subscriptions table to the Drizzle schema with columns: id (uuid primary key), subscriber_email (text, nullable, references subscribers), endpoint (text, not null), p256dh (text, not null), auth (text, not null), user_agent (text), created_at (timestamp), last_used (timestamp), preferences (jsonb default {articles: true, episodes: true, breaking: true}). (4) Add these API endpoints: GET /api/public/vapid-key returns { publicKey: VAPID_PUBLIC_KEY }. POST /api/public/push/subscribe accepts { subscription: PushSubscription object, email?: string, preferences?: object } and upserts into device_push_subscriptions. PUT /api/public/push/preferences accepts { endpoint: string, preferences: object } and updates preferences. DELETE /api/public/push/unsubscribe accepts { endpoint: string } and removes the subscription. (5) Add a helper function sendPushToAll(payload, filter) that queries device_push_subscriptions, filters by preferences, and calls webpush.sendNotification for each. Handle 410 Gone responses by deleting stale subscriptions.

PART B - CLIENT SUBSCRIPTION FLOW: (1) Create client/src/hooks/use-push-notifications.ts. On mount, check if the browser supports Push API and service worker. Fetch the VAPID public key from GET /api/public/vapid-key. Provide functions: requestPermission() that calls Notification.requestPermission(), subscribe() that calls sw.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: vapidPublicKey }) and sends the resulting subscription to POST /api/public/push/subscribe, unsubscribe() that unsubscribes and calls DELETE, updatePreferences(prefs) that calls PUT. Track state: isSupported, isSubscribed, permission status. (2) In the service worker (client/public/sw.js), add a push event listener: self.addEventListener('push', (event) => { const data = event.data?.json() || {}; event.waitUntil(self.registration.showNotification(data.title || 'New Content', { body: data.body, icon: '/icon-192.png', badge: '/icon-192.png', data: { url: data.url || '/home' }, tag: data.tag || 'default' })); }). Add a notificationclick event listener that opens the URL from event.notification.data.url using clients.openWindow().

PART C - NOTIFICATION PREFERENCES UI: (1) Add a notification bell icon button to the AudienceLayout header (near the hamburger menu). When tapped: if not subscribed, show a friendly modal explaining push benefits ('Get notified when new episodes drop and breaking news publishes') with an 'Enable Notifications' button that calls requestPermission then subscribe. If already subscribed, show a dropdown with three toggles: New Articles, New Episodes, Breaking News. Toggles call updatePreferences. (2) In the mobile hamburger menu, add a 'Notifications' link that opens the same preferences. Show a dot indicator on the bell when notifications are not yet enabled.

PART D - TRIGGER NOTIFICATIONS: (1) In the existing article publishing flow (wherever articles/episodes status changes to 'published'), call sendPushToAll with the article/episode title, description snippet, and URL. Filter by preferences (articles filter for article type, episodes for episode type). (2) Add a 'Send Push Notification' button in the admin Content Factory or article detail view that lets staff manually trigger a push for a specific article/episode.
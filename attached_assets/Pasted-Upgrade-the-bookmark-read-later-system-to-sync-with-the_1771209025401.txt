Upgrade the bookmark/read-later system to sync with the server when a subscriber is logged in, while keeping localStorage as a fallback for anonymous users.

(1) Add a subscriber_bookmarks table to the Drizzle schema: id (uuid primary key), subscriber_email (text, not null, references subscribers), article_id (text, not null), article_title (text), article_description (text, nullable), cover_image (text, nullable), podcast_id (text), podcast_title (text, nullable), reading_time (text, nullable), published_at (timestamp, nullable), saved_at (timestamp, default now), unique constraint on (subscriber_email, article_id).

(2) Add these API endpoints: GET /api/public/bookmarks/:email returns all bookmarks for the subscriber sorted by saved_at desc. POST /api/public/bookmarks accepts { email, article } and upserts the bookmark. DELETE /api/public/bookmarks accepts { email, articleId } and removes it. POST /api/public/bookmarks/sync accepts { email, bookmarks: [] } and performs a full sync (server merges with local, returns the merged list). All endpoints should use the publicSubscribeLimit rate limiter.

(3) Upgrade client/src/hooks/use-read-later.ts: import getSubscriberEmail. On mount, check if a subscriber email exists in localStorage. If yes, fetch bookmarks from GET /api/public/bookmarks/:email and merge with any localStorage bookmarks (union by article ID, keep the newest saved_at for duplicates). When saving or removing an article: if subscriber email exists, also call the POST or DELETE API endpoint in addition to updating localStorage. Add a syncBookmarks() function that calls POST /api/public/bookmarks/sync with the full localStorage list and updates local state with the server response. Call syncBookmarks() once on mount when subscriber email is present. This way localStorage is always the fast local cache, and the server is the durable backup.

(4) Keep the existing localStorage-only behavior for users who have not subscribed. The upgrade should be invisible to anonymous users.
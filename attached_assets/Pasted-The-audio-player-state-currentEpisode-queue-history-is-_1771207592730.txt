The audio player state (currentEpisode, queue, history) is lost when AudioPlayerProvider remounts during navigation, even though the audio element persists as a singleton. Fix this by storing all player state globally alongside the audio element.

Replace the ENTIRE contents of client/src/components/AudioPlayerProvider.tsx with this:

import { createContext, useContext, useState, useRef, useCallback, useEffect, useSyncExternalStore, type ReactNode } from "react";

export interface AudioEpisode {
  id: string;
  title: string;
  podcastTitle: string;
  audioUrl: string;
  coverImage?: string | null;
  duration?: string | null;
  podcastId?: string;
}

interface AudioPlayerContextType {
  currentEpisode: AudioEpisode | null;
  isPlaying: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  playbackRate: number;
  queue: AudioEpisode[];
  play: (episode: AudioEpisode) => void;
  pause: () => void;
  resume: () => void;
  seek: (time: number) => void;
  setVolume: (v: number) => void;
  setPlaybackRate: (r: number) => void;
  addToQueue: (episode: AudioEpisode) => void;
  playNext: () => void;
  playPrevious: () => void;
}

// ─── Global singleton state (survives React unmounts) ───
const globalState = {
  audio: null as HTMLAudioElement | null,
  currentEpisode: null as AudioEpisode | null,
  queue: [] as AudioEpisode[],
  history: [] as AudioEpisode[],
  volume: 1,
  playbackRate: 1,
  _version: 0,
  _listeners: new Set<() => void>(),
};

function getAudio(): HTMLAudioElement {
  if (!globalState.audio) {
    const audio = document.createElement("audio");
    audio.preload = "metadata";
    audio.style.display = "none";
    document.body.appendChild(audio);
    globalState.audio = audio;
  }
  return globalState.audio;
}

function notify() {
  globalState._version++;
  globalState._listeners.forEach((l) => l());
}

function subscribe(listener: () => void) {
  globalState._listeners.add(listener);
  return () => globalState._listeners.delete(listener);
}

function getVersion() {
  return globalState._version;
}

const AudioPlayerContext = createContext<AudioPlayerContextType | null>(null);

export function useAudioPlayer() {
  const ctx = useContext(AudioPlayerContext);
  if (!ctx) throw new Error("useAudioPlayer must be used within AudioPlayerProvider");
  return ctx;
}

export function useAudioPlayerOptional() {
  return useContext(AudioPlayerContext);
}

export function AudioPlayerProvider({ children }: { children: ReactNode }) {
  const audio = getAudio();
  const [, forceRender] = useState(0);

  // Subscribe to global state changes
  useSyncExternalStore(subscribe, getVersion, getVersion);

  // Set up audio event listeners (add/remove on mount/unmount)
  useEffect(() => {
    const onTimeUpdate = () => forceRender((n) => n + 1);
    const onDurationChange = () => forceRender((n) => n + 1);
    const onPlay = () => notify();
    const onPause = () => notify();
    const onEnded = () => {
      if (globalState.queue.length > 0) {
        const next = globalState.queue[0];
        globalState.queue = globalState.queue.slice(1);
        playEpisode(next);
      } else {
        notify();
      }
    };

    audio.addEventListener("timeupdate", onTimeUpdate);
    audio.addEventListener("durationchange", onDurationChange);
    audio.addEventListener("play", onPlay);
    audio.addEventListener("pause", onPause);
    audio.addEventListener("ended", onEnded);

    return () => {
      audio.removeEventListener("timeupdate", onTimeUpdate);
      audio.removeEventListener("durationchange", onDurationChange);
      audio.removeEventListener("play", onPlay);
      audio.removeEventListener("pause", onPause);
      audio.removeEventListener("ended", onEnded);
    };
  }, []);

  function playEpisode(episode: AudioEpisode) {
    if (!episode.audioUrl) return;
    if (globalState.currentEpisode) {
      globalState.history = [globalState.currentEpisode, ...globalState.history.slice(0, 49)];
    }
    globalState.currentEpisode = episode;
    audio.src = episode.audioUrl;
    audio.volume = globalState.volume;
    audio.playbackRate = globalState.playbackRate;
    audio.play().catch((err) => console.error("Audio play error:", err));

    if ("mediaSession" in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: episode.title,
        artist: episode.podcastTitle,
        album: "MediaTech Empire",
        artwork: episode.coverImage ? [{ src: episode.coverImage, sizes: "512x512", type: "image/png" }] : [],
      });
      navigator.mediaSession.setActionHandler("play", () => audio.play());
      navigator.mediaSession.setActionHandler("pause", () => audio.pause());
      navigator.mediaSession.setActionHandler("seekbackward", () => { audio.currentTime = Math.max(0, audio.currentTime - 15); });
      navigator.mediaSession.setActionHandler("seekforward", () => { audio.currentTime = Math.min(audio.duration || 0, audio.currentTime + 30); });
    }
    notify();
  }

  const value: AudioPlayerContextType = {
    currentEpisode: globalState.currentEpisode,
    isPlaying: !audio.paused && !!audio.src,
    currentTime: audio.currentTime || 0,
    duration: audio.duration || 0,
    volume: globalState.volume,
    playbackRate: globalState.playbackRate,
    queue: globalState.queue,
    play: playEpisode,
    pause: () => audio.pause(),
    resume: () => { audio.play().catch(() => {}); },
    seek: (time: number) => { audio.currentTime = time; },
    setVolume: (v: number) => { globalState.volume = v; audio.volume = v; notify(); },
    setPlaybackRate: (r: number) => { globalState.playbackRate = r; audio.playbackRate = r; notify(); },
    addToQueue: (episode: AudioEpisode) => { globalState.queue = [...globalState.queue, episode]; notify(); },
    playNext: () => {
      if (globalState.queue.length > 0) {
        const next = globalState.queue[0];
        globalState.queue = globalState.queue.slice(1);
        playEpisode(next);
      }
    },
    playPrevious: () => {
      if (globalState.history.length > 0) {
        const prev = globalState.history[0];
        globalState.history = globalState.history.slice(1);
        playEpisode(prev);
      }
    },
  };

  return <AudioPlayerContext.Provider value={value}>{children}</AudioPlayerContext.Provider>;
}

This version stores currentEpisode, queue, history, volume, and playbackRate in module-level variables that persist even when React unmounts and remounts the component. The audio element and all its state survive navigation completely outside of React's lifecycle.